<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zac&#39;s Blog</title>
    <link>https://zacash.cn/post/</link>
    <description>Recent content in Posts on Zac&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Copyright © 2020, Copyright Zac</copyright>
    <lastBuildDate>Tue, 11 Aug 2020 20:42:28 +0800</lastBuildDate>
    
	<atom:link href="https://zacash.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Interface Delegation</title>
      <link>https://zacash.cn/post/interface-delegation/</link>
      <pubDate>Tue, 11 Aug 2020 20:42:28 +0800</pubDate>
      
      <guid>https://zacash.cn/post/interface-delegation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-classes/#7&#34;&gt;接口委托（Interface delegation）&lt;/a&gt; 是一种高级技术，接口的方法由 helper 或 delegate 对象实现，然后给别的类使用。当我们在一系列不相关的类中使用接口时，这项技术会很有用：我们将需要使用的接口的函数添加到单独的 helper 类中，别的类使用 helper 类的实例来实现这个函数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Introducing Indigo</title>
      <link>https://zacash.cn/post/introducing-indigo/</link>
      <pubDate>Mon, 10 Aug 2020 09:00:00 -0400</pubDate>
      
      <guid>https://zacash.cn/post/introducing-indigo/</guid>
      <description>&lt;p&gt;Indigo is a lightweight theme for &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; with &lt;a href=&#34;https://indieweb.org&#34;&gt;IndieWeb&lt;/a&gt; features baked in. It&amp;rsquo;s great for longer-form blogging, placing its focus on distraction-free reading and beautiful typefaces.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Lambdas and High-order Functions</title>
      <link>https://zacash.cn/post/lambdas-and-high-order-functions/</link>
      <pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/lambdas-and-high-order-functions/</guid>
      <description>&lt;p&gt;除了传统命名的函数外，Kotlin 还支持 &lt;a href=&#34;https://kotlinlang.org/docs/reference/lambdas.html&#34;&gt;lambdas&lt;/a&gt;. &lt;em&gt;lambda&lt;/em&gt; 是组成函数的表达式，一个没有名称的函数。lambda 表达式可以作为数据传递。在其他语言中，lambda 被称为 &lt;em&gt;匿名函数（anonymous function）&lt;/em&gt;，&lt;em&gt;函数字面量（function literals）&lt;/em&gt; 或类似名称。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Use Hilt in Android</title>
      <link>https://zacash.cn/post/use-hilt-in-android/</link>
      <pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/use-hilt-in-android/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;If you want to use dagger in  your project, you may have 2 or 3 different sources, different samples, different blog posts. All of them use a different set-up, and all of them use Dagger in a different way, so it&amp;rsquo;s very difficult to understand all the topics and relate them together. So that&amp;rsquo;s why Google create a common guidance, a common ground.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Threads and Locks</title>
      <link>https://zacash.cn/post/threads-and-locks/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/threads-and-locks/</guid>
      <description>&lt;p&gt;Threads are created and managed by the classes Thread and ThreadGroup. Creating a Thread object creates a thread, and that is the only way to create a thread. When the thread is created, it is not yet active; it begins to run when its start method is called.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WebSocket 和长轮询</title>
      <link>https://zacash.cn/post/websocket-and-long-polling/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/websocket-and-long-polling/</guid>
      <description>&lt;p&gt;客户端的网络请求大部分都建立在请求/响应模式的 HTTP/HTTPS 协议之下，AJAX 技术使页面看起来更加动态。尽管如此，所有的 HTTP 连接仍由客户端控制，需要用户交互或定时轮询（periodic polling）才能从服务端加载新数据。&lt;/p&gt;
&lt;p&gt;通过长轮询，客户端打开与服务端的 HTTP 连接，并保持连接直到服务端返回响应，只要服务端有新的数据，它就会发送响应。然而这些技术有共同的问题：它们带有 HTTP 的开销，并不适合低延时应用的需求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JVM Architecture in A Nutshell</title>
      <link>https://zacash.cn/post/jvm-arch-in-a-nutshell/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/jvm-arch-in-a-nutshell/</guid>
      <description>&lt;p&gt;跨平台的本质是因为汇编指令的不同.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JVM Mechanics</title>
      <link>https://zacash.cn/post/jvm-mechanics/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/jvm-mechanics/</guid>
      <description>&lt;p&gt;Class 文件的结构&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Intro to HashMap</title>
      <link>https://zacash.cn/post/intro-to-hashmap/</link>
      <pubDate>Wed, 15 Jul 2020 15:11:27 +0800</pubDate>
      
      <guid>https://zacash.cn/post/intro-to-hashmap/</guid>
      <description>&lt;p&gt;Hash table based implementation of the Map interface.  This implementation provides all of the optional map operations, and permits null values and the null key.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Intro to Hybrid App</title>
      <link>https://zacash.cn/post/intro-to-hybrid-app/</link>
      <pubDate>Sat, 04 Jul 2020 15:45:14 +0800</pubDate>
      
      <guid>https://zacash.cn/post/intro-to-hybrid-app/</guid>
      <description>Hybrid App 的几种方案   PhoneGap/Cordova
WebView 作为用户界面，以 Javascript 作为基本逻辑，以及和中间件通信，再由中间件访问底层 API 的方式，进行 App 开发。
  React Native/Weex
使用前端技术开发，通过 JSBridge 将 Javascript 代码解析的 Virtual DOM 传递到 Native 并使用原生进行渲染。
  Native/H5 混合开发
在原生的架构基础上，嵌入 WebView 业务逻辑，一般有 Native 和 Web 前端开发人员组成。Native 写好基本的架构以及 API 让 Web 开发人员开发页面以及大部分渲染。
  PhoneGap/Cordova PhoneGap 由 Apache 接管后改名为 Cordova，实际上是一个项目。Cordova 其实不应该称为 Hybrid 方案。因为，它的目标是全面使用前端技术开发移动应用，而不是前端和原生混合使用。不过，这些框架和 React Native 的目标是一致的：使用前端技术开发移动应用，提高工程效率。
Cordova 让前端技术尽可能多的完成开发工作，只有在前端无法直接调用的原生系统功能方面提供了前端可用的接口。主流的 Cordova 项目都将业务逻辑实现在一个 WebView 中，目标是让开发者使用前端技术就能完成一个应用开发。这种做法需要一个前提——前端技术可以解决移动开发的所有需求。
Cordova 架构图  Web App 是开发人员编写代码的地方，应用以网页的形式呈现，在一个 index.</description>
    </item>
    
    <item>
      <title>Intro to Service</title>
      <link>https://zacash.cn/post/intro-to-service/</link>
      <pubDate>Sat, 04 Jul 2020 11:08:11 +0800</pubDate>
      
      <guid>https://zacash.cn/post/intro-to-service/</guid>
      <description>查看进程基本信息 使用 adb shell ps|grep com.tencent.mobileqq 可以查看 QQ 应用进程相关的基本信息
Zac:tivi Zac$ adb shell ps | grep com.tencent.mobileqq # curr_user pid process name u0_a163 6779 669 1638852 27152 0 0 S com.tencent.mobileqq:MSF u0_a163 22001 669 1915536 224004 0 0 S com.tencent.mobileqq u0_a163 27829 669 1670960 236668 0 0 S com.tencent.mobileqq:qzone 进程的划分 为了确定在内存不足时 kill 哪些进程，Android 会依据进程中运行的组件（Activity/Service/BroadcastReceiver）和这些组件的状态，划分每个进程的重要层次结构（importance hierarchy）。这些进程按重要性排序:
前台进程（foreground process） 前台进程是用户当前正在执行的操作所必须的进程，应用进程内的组件可能以不同形式让其处于前台：
 Activity 处于用户正在交互状态（onResume() 方法已调用） BroadcastReceiver 正在运行（BroadcastReceiver.onReceive() 方法正在执行） Service 的回调正在执行代码（Service.onCreate(), Service.onStart(), Service.onDestroy()）  Android 系统中只有少数这样的进程，而且只有在内存太低且无法运行这些进程时，才会 kill 这些进程。</description>
    </item>
    
    <item>
      <title>Java Basic</title>
      <link>https://zacash.cn/post/java-basic/</link>
      <pubDate>Fri, 03 Jul 2020 09:28:31 +0800</pubDate>
      
      <guid>https://zacash.cn/post/java-basic/</guid>
      <description>🌟答案的组织策略：知道是什么，知道为什么，知道怎么用
0.JDK 和 JRE 有什么区别？  JDK 包含 JRE，同时还包含编译 Java 源码的编译器 javac，还包含了很多 Java 程序调试和分析的工具。 加分项：除了 javac 还了解哪些命令行工具，它们的用途是什么？  jcmd：综合工具 jps：虚拟机进程状况工具 jinfo：虚拟机配置信息工具 jstat：虚拟机统计信息监视工具 jmap：Java 内存映像工具 jhat：虚拟机堆转储快照分析工具 jstack：Java 堆栈追踪工具   加分项jstat 用过吗，有哪些参数？  -class：监视类装载、卸载数量、总空间和类装载所耗费的时间 -gc：监视 Java 堆的状况，包括 Eden 区，两个 survior 区，老年代、永久代等的容量，已用空间、GC 时间合计等统计    1.equals 和 == 的差别？ 两者都是判断等价性，区别要从入参类型来看：
  对于基本类型，他们是比较值是否相等
  对于引用类型，他们是判断引用的是否为同一对象
  考察点：equals 的概念
  🌟实际要求：平时对源码的深挖意识即技术钻研和批判性思维
  考察目的：
 基础知识的扎实程度 候选人对技术的热情    2.</description>
    </item>
    
    <item>
      <title>Top 10 Kotlin Questions in StackOverflow</title>
      <link>https://zacash.cn/post/top-10-kotlin-questions/</link>
      <pubDate>Fri, 19 Jun 2020 22:03:29 +0800</pubDate>
      
      <guid>https://zacash.cn/post/top-10-kotlin-questions/</guid>
      <description>IntArray vs. Array&amp;lt;Int&amp;gt;   In java code
 IntArray: int[] Array&amp;lt;Int&amp;gt;: Integer[]    Create method:
 IntArray:  val intArray : IntArray = intArrayOf(1, 2, 3, 4, 5)  Array&amp;lt;Int&amp;gt;:  val arrayOfInts : Array&amp;lt;Int&amp;gt; = arrayOf(1, 2, 3, 4, 5)   Iterable vs. Sequence   Usage
 Iterable:  getPeople() .filter { it.age &amp;gt;= 18 } .map { it.name } .take(5)  Sequence: start with asSequence() and end with toList() or toSet()&amp;hellip;  getPeople().</description>
    </item>
    
    <item>
      <title>Intro to Build System</title>
      <link>https://zacash.cn/post/intro-to-build-system/</link>
      <pubDate>Fri, 05 Jun 2020 14:49:15 +0800</pubDate>
      
      <guid>https://zacash.cn/post/intro-to-build-system/</guid>
      <description>构建流程（Build process） 简单来说构建流程就是涉及一系列工具和步骤将项目转换成 Android Application Package(APK)。典型的流程如下图所示：
图中所示有4个步骤：
 编译器将源码转换为 DEX 文件(Dalvik 可执行文件，包括运行在 Android 设备的字节码)，并将其他所有内容转换成编译后的资源文件。 APK Packager 将 DEX 文件和编译后的资源文件合并到一个 APK 里。 APK Packager 使用 keystore 为 APK 签名。 在生成最终的 APK 文件之前，Packager 会使用 zipalign 工具  自定义构建配置 Gradle 和 Android 插件可以帮助我们修改 build.gradle 中的这些配置：
构建类型 Build Types 构建类型定义 Gradle 在构建(building)和打包(packaging) App 时使用的某些属性，通常针对开发周期的不同阶段(different stages of development)进行配置。比如：
 debug 构建类型支持 debug 选项，并使用 debug key 为 APK 签名。 release 构建类型则会压缩(shrink)和混淆(obfuscate) APK，并使用 release key 为 APK 签名。  构建 App 时必须指定一个构建类型。可以参考 BuildType DSL，了解配置构建类型属性。</description>
    </item>
    
    <item>
      <title>Fragment in ViewPager</title>
      <link>https://zacash.cn/post/fragment-in-viewpager/</link>
      <pubDate>Mon, 25 May 2020 20:55:31 +0800</pubDate>
      
      <guid>https://zacash.cn/post/fragment-in-viewpager/</guid>
      <description>使用 ViewPager 通常我们使用 ViewPager + TabLayout 主要有这些步骤：
 页面的布局结构:  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.MainActivity&amp;#34; &amp;gt; &amp;lt;com.google.android.material.appbar.AppBarLayout android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:theme=&amp;#34;@style/AppTheme.AppBarOverlay&amp;#34; &amp;gt; ... &amp;lt;com.google.android.material.tabs.TabLayout android:id=&amp;#34;@+id/tabs&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;wrap_content&amp;#34; android:background=&amp;#34;?attr/colorPrimary&amp;#34; /&amp;gt; &amp;lt;androidx.viewpager.widget.ViewPager android:id=&amp;#34;@+id/view_pager&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; app:layout_behavior=&amp;#34;@string/appbar_scrolling_view_behavior&amp;#34; /&amp;gt; &amp;lt;/com.google.android.material.appbar.AppBarLayout&amp;gt; &amp;lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&amp;gt;  在 PagerAdapter 中会指定我们使用的 Fragment:  class SectionsPagerAdapter(private val context: Context, fm: FragmentManager ) : FragmentPagerAdapter(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) { override fun getItem(position: Int): Fragment { return SampleFragment.newInstance(position) } override fun getCount(): Int { return TAB_TITLES.</description>
    </item>
    
    <item>
      <title>Git Basic</title>
      <link>https://zacash.cn/post/git-basic/</link>
      <pubDate>Fri, 15 May 2020 15:55:52 +0800</pubDate>
      
      <guid>https://zacash.cn/post/git-basic/</guid>
      <description>Problem Solving Authentication   Clear saved account &amp;amp; password
Error: fatal:Authentication failed for &#39;remote-url&#39;
git config --system --unset credential.helper
  Save account &amp;amp; password
git config --global credential.helper store
  Remote   Check remote url
git remote -v
  Update remote url
git remote set-url origin newRepoUrl
  </description>
    </item>
    
    <item>
      <title>Intro to Fragments</title>
      <link>https://zacash.cn/post/fragments/</link>
      <pubDate>Thu, 07 May 2020 20:30:50 +0800</pubDate>
      
      <guid>https://zacash.cn/post/fragments/</guid>
      <description>Activity 和 Fragment 生命周期的关联    Activity 状态 Fragment 生命周期方法回调 Fragment 状态     Created onAttach(), onCreate(), onCreateView(), onActivityCreated() Fragment 添加到 Activity 且视图已初始化   Started onStart() Fragment 活跃并可见   Resumed onResume() Fragment 活跃并获取焦点   Paused onPause() Fragment 暂停   Stopped onStop() Fragment 停止并不再可见   Destroyed onDestroyView(), onDestroy(), onDetach() Fragment 销毁    Fragment 重要的生命周期方法的使用  onAttach(): Fragment 在被 attach 到宿主 Activity 时回调，可以在该方法里检查宿主 Activity 是否实现了某个接口。 onCreateView(): Fragment 的 XML 布局在这个回调方法里初始化，系统调用这个方法来绘制 Fragment 的 UI。 onPause(): 可以在 Fragment 销毁前在该回调方法保存必要数据或状态。 onActivityCreated(): 在宿主 Activity 的 onCreate() 方法调用后回调该方法。可以在该方法做最终的初始化，如检索 View getView().</description>
    </item>
    
    <item>
      <title>Intro to Coroutines</title>
      <link>https://zacash.cn/post/intro-to-coroutines/</link>
      <pubDate>Sat, 25 Apr 2020 11:40:03 +0800</pubDate>
      
      <guid>https://zacash.cn/post/intro-to-coroutines/</guid>
      <description>协程用来解决什么问题 Kotlin 的协程提供了一种全新的并发处理方式，我们可以使用它来简化安卓异步执行的代码。
在 Android 平台上协程主要用来解决两个问题：
 处理耗时任务(Long running tasks) 保证主线程安全(Main-safety)  处理耗时任务 我们常规处理耗时任务是通过异步回调的方式，比如：
fun fetchDoc() { get(&amp;#34;https://doc.qq.com&amp;#34;) { result -&amp;gt; show(result) } } 通过协程的方式是这样：
// 主线程执行 suspend fun fetchDoc() { // 直接返回结果  val result = get(&amp;#34;https://doc.qq.com&amp;#34;) show(result) } // 主线程执行 suspend fun get(url: String) = withContext(Dispatchers.IO) { /*IO 线程池执行*/ } 可以看到通过协程可以直接返回请求结果，而不用管理请求延迟和线程阻塞，这是如何实现的呢？
协程在常规的函数操作 —— invoke 和 return 之外，还新增了2项：
 suspend —— 称为挂起或暂停，用于暂停执行当前协程，并保存所有局部变量 resume —— 让暂停的协程继续执行  那么 suspend 是如何实现的呢？</description>
    </item>
    
    <item>
      <title>Activity Start</title>
      <link>https://zacash.cn/post/activity-launch/</link>
      <pubDate>Wed, 22 Apr 2020 08:10:27 +0800</pubDate>
      
      <guid>https://zacash.cn/post/activity-launch/</guid>
      <description>Task and Back Stack Task 就是执行某项任务时开启的一系列 Activity 的集合，这些 Activity 会按照打开的顺序排列在回退栈 (Back Stack) 中。
Activity 的四种启动模式 (launchMode) 如通过 startActivity(Intent) 启动 Activity A
 standard 模式：标准模式，创建 Activity A 实例并 push 到当前任务栈中 singleTop 模式：栈顶复用模式，如果当前栈顶是 Activity A ，直接复用并调用 onNewIntent(Intent)方法，不会创建新的实例 singleTask 模式：栈内复用模式，如果当前栈内含有 Activity A ，直接复用并调用 onNewIntent(Intent)方法，并清除栈内 Activity A 上方的所有 Activity 实例 singleInstance 模式：在新的任务栈开启 Activity A，如果新的任务栈和 Activity A 已创建，继续开启 Activity A 会调用其 onNewIntent(Intent)方法。  三种 Intent 标记 startActivity(Intent) 方法可以添加 3 种 Intent 标记：
  FLAG_ACTIVITY_NEW_TASK</description>
    </item>
    
    <item>
      <title>Handler in Action</title>
      <link>https://zacash.cn/post/handler-in-action/</link>
      <pubDate>Tue, 14 Apr 2020 21:53:54 +0800</pubDate>
      
      <guid>https://zacash.cn/post/handler-in-action/</guid>
      <description>Memory Leaks 1.1 背景 1.Handler 在使用下面这种实现方式处理消息时:
class MainActivity : Activity() { private val mLeakedHandler = object : Handler() { override fun handleMessage(msg: Message) { super.handleMessage(msg) } } Android Lint 会发出这样的警告: This Handler class should be static or leaks might occur(anonymous android.os.Handler)
2.我们在 Handler 构造方法里同样可以看到：
public Handler(@Nullable Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&amp;lt;? extends Handler&amp;gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp; (klass.getModifiers() &amp;amp; Modifier.</description>
    </item>
    
    <item>
      <title>Handler in Code</title>
      <link>https://zacash.cn/post/handler-in-code/</link>
      <pubDate>Sun, 12 Apr 2020 20:36:33 +0800</pubDate>
      
      <guid>https://zacash.cn/post/handler-in-code/</guid>
      <description>Handler 的创建  在主线程(UI Thread)中：  class MainActivity : Activity { private val mLeakedHandler = object : Handler() { override fun handleMessage(msg: Message) { super.handleMessage(msg) } } }  在子线程中：  val thread = object : Thread() { override fun run() { Looper.prepare() val handler = object : Handler() { override fun handleMessage(msg: Message) { super.handleMessage(msg) } } Looper.loop() } } 为什么在子线程创建 Handler 需要准备 Looper，而主线程却不用 因为 ActivityThread 中的 main() 方法已经为我们初始化了 Looper</description>
    </item>
    
    <item>
      <title>Hugo Basic</title>
      <link>https://zacash.cn/post/hugo-basic/</link>
      <pubDate>Sat, 04 Apr 2020 09:25:04 +0800</pubDate>
      
      <guid>https://zacash.cn/post/hugo-basic/</guid>
      <description>Add new content hugo new posts/article-name.md
Article meta info --- title: &amp;#34;New Article&amp;#34; date: 2020-04-04T09:25:04+08:00 description: &amp;#34;Hugo 的简单用法&amp;#34; tags: [&amp;#34;hugo&amp;#34;, &amp;#34;pages&amp;#34;] categories: [&amp;#34;hugo&amp;#34;] draft: true --- Start server with drafts enabled hugo server -D
Customize the theme Open up config.toml in a text editor:
baseURL = &amp;#34;https://example.org/&amp;#34; languageCode = &amp;#34;en-us&amp;#34; title = &amp;#34;My New Hugo Site&amp;#34; theme = &amp;#34;ananke&amp;#34; Build static pages hugo -D output will be in ./public/ directory by default (-d/--destination flag to change it, or set publishdir in the config file)</description>
    </item>
    
    <item>
      <title>Check State Loss</title>
      <link>https://zacash.cn/post/check-state-loss/</link>
      <pubDate>Tue, 11 Feb 2020 16:30:26 +0800</pubDate>
      
      <guid>https://zacash.cn/post/check-state-loss/</guid>
      <description>背景 最近做的一个 DialogFragment 在少数设备上会偶发闪退，Fabric 上的 Stacktrace 信息如下：
Fatal Exception: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(SourceFile) at android.support.v4.app.FragmentManagerImpl.enqueueAction(SourceFile) at android.support.v4.app.BackStackRecord.commitInternal(SourceFile) at android.support.v4.app.BackStackRecord.commit(SourceFile) at android.support.v4.app.DialogFragment.show(SourceFile） 看起来是弹窗在 show 的时候，发生了 state loss，粗略 copy 了下 StackOverflow 上的回答，做了如下修改：
fun show(manager: FragmentManager?) { try { val ft = manager?.beginTransaction() ft?.add(this, &amp;#34;tag of dialog&amp;#34;) ft?.commitAllowingStateLoss() } catch (e: Exception) { } } 重写了 show 方法，允许 state loss，并加了异常捕捉，后续观察 Fabric， show 的时候的确没再出现异常情况，但 dismiss 的时候还是有闪退出现，异常信息如下：
Fatal Exception: java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zacash.cn/post/when-to-use-lazy-or-lateinit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/post/when-to-use-lazy-or-lateinit/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>