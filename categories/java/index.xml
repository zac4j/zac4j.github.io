<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Zac&#39;s blog</title>
    <link>https://zacash.cn/categories/java/</link>
    <description>Recent content in java on Zac&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright Zac &amp;copy; 2022
</copyright>
    <lastBuildDate>Tue, 29 Mar 2022 21:46:30 +0800</lastBuildDate><atom:link href="https://zacash.cn/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Intro to Executor</title>
      <link>https://zacash.cn/posts/intro-to-executor/</link>
      <pubDate>Tue, 29 Mar 2022 21:46:30 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/intro-to-executor/</guid>
      <description>Executor, ExecutorService, Executors 通常我们执行多个 Runnable task 会使用这种形式：
val t1 = Thread {  // Runnable task1 }  val t2 = Thread {  // Runnable task2 }  t1.start() t2.start() 如果是执行 N 个 Runnable tasks，对每个 Runnable task 创建一个 Thread 执行显然不合适，我们可以通过实现 Executor 接口来编排 Runnable task 的执行：
class SerialExecutor(private val executor: Executor): Executor {   private val tasks: ArrayDeque&amp;lt;Runnable&amp;gt; = ArrayDeque()  private var active: Runnable? = null   @Synchronized  override fun execute(r: Runnable?</description>
    </item>
    
    <item>
      <title>JVM Basic - Rumtime Data Area</title>
      <link>https://zacash.cn/posts/jvm-basic-rt-data-area/</link>
      <pubDate>Thu, 24 Mar 2022 08:44:28 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/jvm-basic-rt-data-area/</guid>
      <description>前面说了类加载器，我们接下来看看运行时数据区(Run-Time Data Areas)
Run-Time Data Areas The pc Register JVM 可以支持多个线程同时运行，每个线程都有自己的 pc 寄存器(program counter register)。在任意时间点，任一线程在执行某个方法的代码，即该线程的当前方法(current method)。
 如果该方法是 native 的，pc 寄存器的值是 undefined。 如果该方法不是 native 的，pc 寄存器包含当前正在执行指令的地址。  JVM 的 pc 寄存器容量足够在特定平台上保存 returnAddress (returnAddress 保存着指向JVM操作码指令的指针) 或 native 指针。
JVM 栈 (Stacks) 每个线程都有一个私有的 JVM 栈，与线程同时创建。JVM 栈存储 栈帧(frames) 对于栈帧仅有两种操作：push 和 pop。JVM 栈的内存不必是连续的。
线程执行的每个 method calls 都存储在对应的栈中，包括入参、局部变量、中间计算和其他数据。方法完成后，JVM 将从栈中删除对应的条目，完成所有的方法调用后，栈将变为空，并且在终止线程前，销毁该栈。
存储在栈中的数据仅适用于对应线程，对别的线程不适用。因此，可以说局部数据是线程安全的。
 第一版的 Java 虚拟机规范 The Java® Virtual Machine Specification, JVM 栈 被称为 Java 栈 (Java stack)
 JVM 规范允许Java虚拟机栈具有固定大小，或者根据计算要求动态伸缩。 如果Java虚拟机栈的大小固定，则在创建每个Java虚拟机栈时可以独立选择它们的大小。</description>
    </item>
    
    <item>
      <title>JVM Basic - ClassLoader</title>
      <link>https://zacash.cn/posts/jvm-basic-classloader/</link>
      <pubDate>Wed, 23 Mar 2022 08:44:28 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/jvm-basic-classloader/</guid>
      <description>类加载器（ClassLoader） 什么是类加载器 类加载器是 JRE 的一部分，负责在运行时将 Java 类动态加载到 JVM，有了类加载器，JVM 无需了解底层文件或文件系统即可运行Java程序。
类加载器不会一次将全部类加载到内存里，而是在程序需要时加载。
JVM 内置的类加载器类型   Bootstrap class loader
每个 JVM 实现必须有一个 bootstrap 类加载器。它负责 JDK 内部类，通常是 rt.jar 和位于 JAVA_HOME/jre/lib 目录下的其他核心类，该路径通常被称为引导路径(bootstrap path)。该类加载器由 C/C++ 语言实现。
  Extension class loader
Bootstrap 的子类加载器，它加载扩展目录 JAVA_HOME/jre/lib/ext 或 java.ext.dirs 指定路径下的类。它在 sun.misc.Launcher$ExtClassLoader 类中由 Java 语言实现。
  System/Application class loader
Extension 的子类加载器。它负责加载 App 层级的类，它加载在 classpath 环境变量、-classpath、-cp 命令行选项中找到的文件。它在 sun.misc.Launcher$AppClassLoader 类中由 Java 语言实现。
  自定义的类加载器 在需要从本地或网络加载类的场景，我们可能需要使用自定义类加载器。
使用场景 自定义类加载器不仅对在运行时加载类有帮助，还包括：
 修改现有字节码，如织入代理 动态创建适合用户需求的类。如 JDBC 中，通过动态类加载完成不同驱动实现(driver implementations)之间的切换。 实现类版本控制机制，如为具有相同名称和包名的类加载不同的字节码（热修复）。这可以通过 URL 类加载器或自定义加载器完成。  我们可以自定义类加载器实现指定类的加载：</description>
    </item>
    
    <item>
      <title>Process, Threads and Locks</title>
      <link>https://zacash.cn/posts/threads-and-locks/</link>
      <pubDate>Mon, 27 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zacash.cn/posts/threads-and-locks/</guid>
      <description>&lt;p&gt;Threads are created and managed by the classes Thread and ThreadGroup. Creating a Thread object creates a thread, and that is the only way to create a thread. When the thread is created, it is not yet active; it begins to run when its start method is called.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java Basic</title>
      <link>https://zacash.cn/posts/java-basic/</link>
      <pubDate>Fri, 03 Jul 2020 09:28:31 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/java-basic/</guid>
      <description>🌟答案的组织策略：知道是什么，知道为什么，知道怎么用
0.JDK 和 JRE 有什么区别？  JDK 包含 JRE，同时还包含编译 Java 源码的编译器 javac，还包含了很多 Java 程序调试和分析的工具。 加分项：除了 javac 还了解哪些命令行工具，它们的用途是什么？  jcmd：综合工具 jps：虚拟机进程状况工具 jinfo：虚拟机配置信息工具 jstat：虚拟机统计信息监视工具 jmap：Java 内存映像工具 jhat：虚拟机堆转储快照分析工具 jstack：Java 堆栈追踪工具   加分项jstat 用过吗，有哪些参数？  -class：监视类装载、卸载数量、总空间和类装载所耗费的时间 -gc：监视 Java 堆的状况，包括 Eden 区，两个 survior 区，老年代、永久代等的容量，已用空间、GC 时间合计等统计    1.equals 和 == 的差别？ 两者都是判断等价性，区别要从入参类型来看：
  对于基本类型，他们是比较值是否相等
  对于引用类型，他们是判断引用的是否为同一对象
  考察点：equals 的概念
  🌟实际要求：平时对源码的深挖意识即技术钻研和批判性思维
  考察目的：
 基础知识的扎实程度 候选人对技术的热情    2.Java 中操作字符串有那些类？它们之间有什么区别？  主要有：String，StringBuilder，StringBuffer 区别：StringBuffer 和 StringBuilder 都继承自 AbstractStringBuilder，StringBuffer 具备线程安全性  加分项：String 源码分析  String 是 final 关键字修饰 -&amp;gt; 对象的值不可变 -&amp;gt; 每次操作都会生成新的对象 StringBuffer 和 StringBuilder 对象的值可变，但拼接字符串开销比较小   加分项：StringBuffer 线程安全性分析（查源码、找 synchronized、线程锁）   使用场景：并发必选 StringBuffer，迭代必选 StringBuilder，普通场景选 String，避免中途不必要的类型转换开销  3.</description>
    </item>
    
  </channel>
</rss>
