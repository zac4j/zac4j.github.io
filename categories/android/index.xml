<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Zac&#39;s blog</title>
    <link>https://zacash.cn/categories/android/</link>
    <description>Recent content in Android on Zac&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; Copyright © 2022, Copyright Zac
</copyright>
    <lastBuildDate>Sun, 23 Aug 2020 11:11:13 +0800</lastBuildDate><atom:link href="https://zacash.cn/categories/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Intro to Navigation</title>
      <link>https://zacash.cn/posts/intro-to-navigation/</link>
      <pubDate>Sun, 23 Aug 2020 11:11:13 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/intro-to-navigation/</guid>
      <description>The Jetpack&amp;rsquo;s Navigation component helps us implement navigation feature in a single MainActivity, it contains 3 core parts: Navigation graph, NavHost, NavController.
NavHostFragment NavHostFragment acts as a host for the fragments in the navigation graph.
As the user moves between destination defined in the navigation graph, the NavHostFragment swaps the fragments in and out and manages the Fragment back stack.
In the activity_main.xml layout file, the NavHostFragment is represented by a fragment element with the name android:name=&amp;quot;androidx.</description>
    </item>
    
    <item>
      <title>Intro to Service</title>
      <link>https://zacash.cn/posts/intro-to-service/</link>
      <pubDate>Sat, 04 Jul 2020 11:08:11 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/intro-to-service/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Handler in Action</title>
      <link>https://zacash.cn/posts/handler-in-action/</link>
      <pubDate>Tue, 14 Apr 2020 21:53:54 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/handler-in-action/</guid>
      <description>Memory Leaks 1.1 背景 1.Handler 在使用下面这种实现方式处理消息时:
class MainActivity : Activity() {   private val mLeakedHandler = object : Handler() {  override fun handleMessage(msg: Message) {  super.handleMessage(msg)  }  } Android Lint 会发出这样的警告: This Handler class should be static or leaks might occur(anonymous android.os.Handler)
2.我们在 Handler 构造方法里同样可以看到：
public Handler(@Nullable Callback callback, boolean async) {  if (FIND_POTENTIAL_LEAKS) {  final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();  if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.</description>
    </item>
    
    <item>
      <title>Handler in Details</title>
      <link>https://zacash.cn/posts/handler-in-code/</link>
      <pubDate>Sun, 12 Apr 2020 20:36:33 +0800</pubDate>
      
      <guid>https://zacash.cn/posts/handler-in-code/</guid>
      <description>Handler 的创建  在主线程(UI Thread)中：  class MainActivity: Activity {  private val mLeakedHandler = object: Handler(Looper.getMainLooper()) {  override fun handleMessage(msg: Message) {  super.handleMessage(msg)  }  } }  在子线程中：  val thread = object: Thread() {  override fun run() {  val looper = Looper.prepare()  val handler = object: Handler(Looper.myLooper()) {  override fun handleMessage(msg: Message) {  super.handleMessage(msg)  }  }  Looper.loop()  } } 为什么在子线程创建 Handler 需要准备 Looper，而主线程却不用 因为 ActivityThread 中的 main() 方法已经为我们初始化了 Looper</description>
    </item>
    
  </channel>
</rss>
